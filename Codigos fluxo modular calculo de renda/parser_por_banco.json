// Node 3: Parser de Transações (Routing por Banco)
// Extrai transações baseado no formato de cada banco
// Para adicionar novo banco: 
//   1. Criar função parse[NomeBanco]
//   2. Adicionar no switch de getParserForBank
//   3. Adicionar detecção no Node 2

const item = $input.first();
const { banco, lines, data, keywords } = item.json;

// ============================================
// FUNÇÕES UTILITÁRIAS GERAIS
// ============================================

function extractValue(valueStr) {
  if (!valueStr) return 0;
  let cleaned = String(valueStr)
    .replace(/[^\d,.\-+CD]/g, '')
    .trim();
  const isCredit = cleaned.includes('C');
  const isDebit = cleaned.includes('D');
  cleaned = cleaned.replace(/[CD]/g, '');
  if (cleaned.includes('.') && cleaned.includes(',')) {
    cleaned = cleaned.replace(/\./g, '').replace(',', '.');
  } else if (cleaned.includes(',')) {
    cleaned = cleaned.replace(',', '.');
  }
  let value = parseFloat(cleaned) || 0;
  if (isDebit && value > 0) value = -value;
  if (isCredit && value > 0) value = Math.abs(value);
  return value;
}

function parseValueWithIndicator(parts) {
  for (let i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    if (/[+-]?\s*[\d.]+,\d+\s*[CD]$/i.test(part)) {
      const indicator = part.trim().slice(-1).toUpperCase();
      const numeric = part.trim().slice(0, -1);
      let value = extractValue(numeric);
      if (indicator === 'D') value = -Math.abs(value);
      if (indicator === 'C') value = Math.abs(value);
      return value;
    }
  }
  return extractValue(parts[parts.length - 1] || '');
}

function containsKeyword(text, keywordList) {
  if (!text) return false;
  const normalizedText = text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  return keywordList.some(kw => {
    const normalizedKw = kw.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    return normalizedText.includes(normalizedKw);
  });
}

// ============================================
// FUNÇÕES ESPECÍFICAS DO BANCO INTER
// ============================================

function parseInterExtendedDate(dateStr) {
  const months = {
    'janeiro': '01', 'fevereiro': '02', 'março': '03', 'marco': '03',
    'abril': '04', 'maio': '05', 'junho': '06',
    'julho': '07', 'agosto': '08', 'setembro': '09',
    'outubro': '10', 'novembro': '11', 'dezembro': '12'
  };
  
  const match = dateStr.match(/(\d{1,2})\s+de\s+(\w+)\s+de\s+(\d{4})/i);
  if (match) {
    const day = match[1].padStart(2, '0');
    const monthName = match[2].toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const month = months[monthName];
    const year = match[3];
    if (month) {
      return `${day}/${month}/${year}`;
    }
  }
  return null;
}

function extractInterValue(valueStr) {
  if (!valueStr) return 0;
  
  const isNegative = valueStr.includes('-');
  let cleaned = valueStr.replace(/[^\d,.]/g, '');
  
  if (cleaned.includes('.') && cleaned.includes(',')) {
    cleaned = cleaned.replace(/\./g, '').replace(',', '.');
  } else if (cleaned.includes(',')) {
    cleaned = cleaned.replace(',', '.');
  }
  
  let value = parseFloat(cleaned) || 0;
  
  if (isNegative) {
    value = -Math.abs(value);
  }
  
  return value;
}

// ============================================
// FUNÇÕES ESPECÍFICAS DO NUBANK
// ============================================

function parseNubankDate(dateStr) {
  const months = {
    'jan': '01', 'fev': '02', 'mar': '03', 'abr': '04',
    'mai': '05', 'jun': '06', 'jul': '07', 'ago': '08',
    'set': '09', 'out': '10', 'nov': '11', 'dez': '12'
  };
  
  const match = dateStr.match(/(\d{1,2})\s+([A-Za-z]{3})\s+(\d{4})/i);
  if (match) {
    const day = match[1].padStart(2, '0');
    const monthAbbr = match[2].toLowerCase();
    const month = months[monthAbbr];
    const year = match[3];
    if (month) {
      return `${day}/${month}/${year}`;
    }
  }
  return null;
}

function extractNubankValue(valueStr) {
  if (!valueStr) return 0;
  
  const normalized = valueStr.trim();
  const isNegative = normalized.includes('-');
  
  let cleaned = normalized.replace(/[^\d,.]/g, '');
  
  if (!cleaned) return 0;
  
  if (cleaned.includes('.') && cleaned.includes(',')) {
    cleaned = cleaned.replace(/\./g, '').replace(',', '.');
  } else if (cleaned.includes(',')) {
    cleaned = cleaned.replace(',', '.');
  }
  
  let value = parseFloat(cleaned) || 0;
  
  if (isNegative) {
    value = -Math.abs(value);
  }
  
  return value;
}

function parseNubank(data) {
  const transactions = [];
  const lines = data.split('\n');
  
  let currentDate = '';
  
  // Padrões para ignorar linhas completamente
  const ignoreLinePatterns = [
    /^n[uUvV]$/i,
    /^CPF$/i,
    /^\d{3}\.\d{3}(-\*+)?$/,
    /Agência 0001/i,
    /^\d+-\d+$/,
    /VALORES EM R\$/i,
    /Saldo final do período/i,
    /Saldo inicial/i,
    /Rendimento líquido/i,
    /^Movimentações$/i,
    /Tem alguma dúvida/i,
    /Ouvidoria/i,
    /Extrato gerado dia/i,
    /Nu Financeira/i,
    /Nu Pagamentos/i,
    /CNPJ:/i,
    /Não nos responsabilizamos/i,
    /Asseguramos a autenticidade/i,
    /saldo líquido/i,
    /^\s*---\s*$/,
    /^\d{2} DE [A-Z]+ DE \d{4}/i,
    /^#?\s*\d{2} DE [A-Z]+/i,
    /^\d+ de \d+$/,
    /^[A-Z]\.\s*\(\d+\)\s*Ag/i,  // Continuação de banco "A. (0197) Agência..."
  ];
  
  // Tipos de transação - ENTRADAS
  const entryPatterns = [
    /Transfer[êe]ncia\s+recebida\s+pelo\s+Pix/i,
    /Transfer[êe]ncia\s+Recebida(?!\s+pelo)/i,  // "Transferência Recebida" mas não "pelo Pix"
  ];
  
  // Tipos de transação - SAÍDAS
  const exitPatterns = [
    /Transfer[êe]ncia\s+enviada\s+pelo\s+Pix/i,
    /Pagamento\s+de\s+boleto/i,
    /Compra\s+no\s+d[eé]bito/i,
    /Pagamento\s+de\s+fatura/i,
  ];
  
  // Função auxiliar para extrair data de uma string
  function extractDateFromText(text) {
    const dateMatch = text.match(/(\d{1,2}\s+[A-Za-z]{3}\s+\d{4})/i);
    if (dateMatch) {
      return parseNubankDate(dateMatch[1]);
    }
    return null;
  }
  
  // Função para verificar se é linha de resumo (Total de entradas/saídas)
  function isSummaryLine(text) {
    return /Total\s+de\s+(entradas|sa[ií]das)/i.test(text);
  }
  
  // Função para verificar se é transação
  function getTransactionType(text) {
    if (entryPatterns.some(p => p.test(text))) return 'ENTRY';
    if (exitPatterns.some(p => p.test(text))) return 'EXIT';
    return null;
  }
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    
    // Ignora linhas vazias
    if (!trimmedLine) continue;
    
    // Ignora linhas de cabeçalho/rodapé/separadores
    if (ignoreLinePatterns.some(p => p.test(trimmedLine))) continue;
    
    // Ignora linhas que são apenas separadores de tabela
    if (/^\|\s*---/.test(trimmedLine)) continue;
    
    // ===== FORMATO 1: Linha com tabela (pipes) =====
    if (trimmedLine.includes('|')) {
      const fullContent = trimmedLine.replace(/\|/g, ' ');
      
      // SEMPRE tenta extrair data primeiro (mesmo de linhas de resumo)
      const extractedDate = extractDateFromText(fullContent);
      if (extractedDate) {
        currentDate = extractedDate;
      }
      
      // Se é linha de resumo, pula (mas já guardamos a data)
      if (isSummaryLine(fullContent)) continue;
      
      // Verifica se é uma transação
      const transactionType = getTransactionType(fullContent);
      
      if (transactionType && currentDate) {
        // Separa as colunas para extrair dados
        const parts = trimmedLine.split('|').map(p => p.trim()).filter(p => p);
        
        // Encontra a descrição (parte que contém o tipo de transação)
        let description = '';
        for (const part of parts) {
          if (getTransactionType(part)) {
            description = part.trim();
            break;
          }
        }
        
        // Se não achou descrição específica, usa a segunda coluna não vazia
        if (!description) {
          for (const part of parts) {
            if (part && !extractDateFromText(part) && !/^\s*$/.test(part)) {
              description = part;
              break;
            }
          }
        }
        
        // Encontra o valor - última coluna que parece um número
        let value = 0;
        for (let j = parts.length - 1; j >= 0; j--) {
          const part = parts[j].trim();
          if (/[\d]+[,.][\d]{2}\s*$/.test(part) || /^[+-]?\s*[\d.,]+$/.test(part.replace(/\s/g, ''))) {
            value = extractNubankValue(part);
            if (value !== 0) break;
          }
        }
        
        // Ajusta sinal para saídas
        if (transactionType === 'EXIT' && value > 0) {
          value = -value;
        }
        
        // Adiciona transação se válida
        if (description && value !== 0) {
          transactions.push({
            date: currentDate,
            description: description.substring(0, 200),
            value: value,
            lineNumber: i + 1
          });
        }
      }
      
      continue;
    }
    
    // ===== FORMATO 2: Texto corrido (última página sem tabela) =====
    
    // Tenta extrair data
    const extractedDate = extractDateFromText(trimmedLine);
    if (extractedDate) {
      currentDate = extractedDate;
    }
    
    // Se é linha de resumo, pula
    if (isSummaryLine(trimmedLine)) continue;
    
    // Verifica se é uma transação
    const transactionType = getTransactionType(trimmedLine);
    
    if (transactionType && currentDate) {
      let description = trimmedLine;
      let value = 0;
      
      // Tenta extrair valor do final da linha
      const valueMatch = trimmedLine.match(/([\d]+[,.][\d]{2})\s*$/);
      if (valueMatch) {
        value = extractNubankValue(valueMatch[1]);
        description = trimmedLine.replace(/([\d]+[,.][\d]{2})\s*$/, '').trim();
      }
      
      // Se não achou valor, procura nas próximas linhas
      if (value === 0) {
        for (let j = i + 1; j < lines.length && j <= i + 4; j++) {
          const nextLine = lines[j].trim();
          
          // Para se encontrar nova transação ou nova data
          if (getTransactionType(nextLine) || extractDateFromText(nextLine)) {
            break;
          }
          
          // Procura valor no final da linha
          const nextValueMatch = nextLine.match(/([\d]+[,.][\d]{2})\s*$/);
          if (nextValueMatch) {
            const potentialValue = extractNubankValue(nextValueMatch[1]);
            if (potentialValue !== 0 && Math.abs(potentialValue) < 1000000) {
              value = potentialValue;
              break;
            }
          }
        }
      }
      
      // Ajusta sinal para saídas
      if (transactionType === 'EXIT' && value > 0) {
        value = -value;
      }
      
      // Adiciona transação se válida
      if (description && value !== 0) {
        transactions.push({
          date: currentDate,
          description: description.substring(0, 200),
          value: value,
          lineNumber: i + 1
        });
      }
    }
  }
  
  return transactions;
}

// ============================================
// FUNÇÕES ESPECÍFICAS DO BANRISUL
// ============================================

function parseBanrisulPeriod(data) {
  // Extrai mês e ano do cabeçalho: "PERIODO: NOVEMBRO/2025"
  const months = {
    'janeiro': '01', 'fevereiro': '02', 'marco': '03', 'março': '03',
    'abril': '04', 'maio': '05', 'junho': '06',
    'julho': '07', 'agosto': '08', 'setembro': '09',
    'outubro': '10', 'novembro': '11', 'dezembro': '12'
  };
  
  const match = data.match(/PERIODO:\s*(\w+)\/(\d{4})/i);
  if (match) {
    const monthName = match[1].toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    const month = months[monthName];
    const year = match[2];
    if (month) {
      return { month, year };
    }
  }
  return null;
}

function extractBanrisulValue(valueStr) {
  if (!valueStr) return 0;
  
  const trimmed = valueStr.trim();
  
  // Verifica se é negativo (termina com "-")
  const isNegative = trimmed.endsWith('-');
  
  // Remove tudo exceto dígitos, vírgula e ponto
  let cleaned = trimmed.replace(/[^\d,.]/g, '');
  
  if (!cleaned) return 0;
  
  // Converte formato brasileiro para float
  if (cleaned.includes('.') && cleaned.includes(',')) {
    cleaned = cleaned.replace(/\./g, '').replace(',', '.');
  } else if (cleaned.includes(',')) {
    cleaned = cleaned.replace(',', '.');
  }
  
  let value = parseFloat(cleaned) || 0;
  
  if (isNegative) {
    value = -Math.abs(value);
  }
  
  return value;
}

function parseBanrisul(data) {
  const transactions = [];
  const lines = data.split('\n');
  
  // Extrai período do cabeçalho
  const period = parseBanrisulPeriod(data);
  if (!period) {
    // Sem período, não consegue montar datas completas
    return transactions;
  }
  
  // Padrões para ignorar linhas
  const ignorePatterns = [
    /^SALDO\s*(ANT|NA DATA|ANTERIOR)/i,
    /^\+{2,}/,                              // ++ MOVIMENTOS
    /^NOME:/i,                              // Linha de continuação com nome
    /^---/,
    /^BANKISUL|^BANRISUL/i,
    /^AGENCIA:/i,
    /^CONTA/i,
    /^PERIODO:/i,
    /^IDENTIFICACAO:/i,
    /PARA SIMPLES CONFERENCIA/i,
    /^DIA\s*HISTORICO/i,
    /MOVIMENTOS\s*(DA|NOV|DEZ|JAN|FEV|MAR|ABR|MAI|JUN|JUL|AGO|SET|OUT)/i,
    /^SAC\s*0800/i,
    /^OUVIDORIA/i,
    /EMITIDO\s*AS/i,
    /SEM LANCAMENTOS/i,
    /MOVIMENTOS DA POUPANCA/i,
  ];
  
  // Regex para linha de transação: DIA(2 dígitos) + DESCRIÇÃO + DOCUMENTO + VALOR
  // Exemplos:
  //   03 PIX ENVIADO 192092 385,00-
  //   05 CR.TRANSFERENCIA 155121 400,00
  //   PG CLARO 181171 126,28-  (sem dia, herda do anterior)
  const transactionWithDayRegex = /^(\d{2})\s+(.+?)\s+(\d{6})\s+([\d.,]+-?)$/;
  const transactionNoDayRegex = /^([A-Z].+?)\s+(\d{6})\s+([\d.,]+-?)$/;
  
  // Para linhas em formato de tabela com pipes
  const tableTransactionRegex = /^\|\s*(\d{2})?\s*([A-Z].*?)\s*\|\s*(\d{6})\s*\|\s*([\d.,]+-?)\s*\|?$/i;
  const tableTransactionAltRegex = /^\|\s*([A-Z].*?)\s*\|\s*(\d{6})\s*\|\s*([\d.,]+-?)\s*\|?$/i;
  
  let currentDay = '';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    
    // Ignora linhas vazias
    if (!trimmedLine) continue;
    
    // Ignora linhas de cabeçalho/rodapé/saldo
    if (ignorePatterns.some(p => p.test(trimmedLine))) continue;
    
    // Remove pipes para processamento
    const cleanedLine = trimmedLine.replace(/^\||\|$/g, '').trim();
    
    let day = '';
    let description = '';
    let docNumber = '';
    let valueStr = '';
    let matched = false;
    
    // ===== FORMATO 1: Tabela com pipes =====
    if (trimmedLine.includes('|')) {
      // Formato: | DIA DESCRIÇÃO | DOCUMENTO | VALOR |
      // ou: | DESCRIÇÃO | DOCUMENTO | VALOR |
      const parts = trimmedLine.split('|').map(p => p.trim()).filter(p => p);
      
      if (parts.length >= 3) {
        const firstPart = parts[0];
        const lastPart = parts[parts.length - 1];
        const docPart = parts[parts.length - 2];
        
        // Verifica se último é valor
        if (/^[\d.,]+-?$/.test(lastPart) && /^\d{6}$/.test(docPart)) {
          valueStr = lastPart;
          docNumber = docPart;
          
          // Verifica se primeiro parte começa com dia
          const dayMatch = firstPart.match(/^(\d{2})\s+(.+)$/);
          if (dayMatch) {
            day = dayMatch[1];
            description = dayMatch[2].trim();
          } else {
            description = firstPart;
          }
          matched = true;
        }
      }
    }
    
    // ===== FORMATO 2: Texto corrido com dia =====
    if (!matched) {
      const matchWithDay = cleanedLine.match(transactionWithDayRegex);
      if (matchWithDay) {
        day = matchWithDay[1];
        description = matchWithDay[2].trim();
        docNumber = matchWithDay[3];
        valueStr = matchWithDay[4];
        matched = true;
      }
    }
    
    // ===== FORMATO 3: Texto corrido sem dia (herda anterior) =====
    if (!matched) {
      const matchNoDay = cleanedLine.match(transactionNoDayRegex);
      if (matchNoDay) {
        description = matchNoDay[1].trim();
        docNumber = matchNoDay[2];
        valueStr = matchNoDay[3];
        matched = true;
      }
    }
    
    if (!matched) continue;
    
    // Atualiza dia atual se encontrou novo dia
    if (day) {
      currentDay = day;
    }
    
    // Precisa ter dia (atual ou herdado)
    if (!currentDay) continue;
    
    // Ignora linhas de saldo que passaram pelos filtros
    if (/SALDO/i.test(description)) continue;
    
    // Monta data completa: DD/MM/YYYY
    const fullDate = `${currentDay}/${period.month}/${period.year}`;
    
    // Extrai valor
    const value = extractBanrisulValue(valueStr);
    
    // Ignora se valor for 0 ou descrição vazia
    if (value === 0 || !description) continue;
    
    transactions.push({
      date: fullDate,
      description: description.substring(0, 200),
      value: value,
      lineNumber: i + 1
    });
  }
  
  return transactions;
}
// ============================================
// PARSERS POR BANCO (LINHA A LINHA)
// ============================================

function parseInter(data) {
  const transactions = [];
  const lines = data.split('\n');
  
  let currentDate = '';
  let i = 0;
  
  while (i < lines.length) {
    const line = lines[i].trim();
    
    // Ignora linhas vazias e de cabeçalho/rodapé
    if (!line || 
        line.includes('Fale com a gente') ||
        line.includes('SAC:') ||
        line.includes('Ouvidoria:') ||
        line.includes('Deficiência de fala') ||
        line.includes('Solicitado em:') ||
        line.includes('CPF/CNPJ:') ||
        line.includes('Período:') ||
        /^\s*\|\s*Saldo total/.test(line) ||
        /^\s*\|\s*R\$.*bloqueado/.test(line)) {
      i++;
      continue;
    }
    
    // Detecta linha de data no formato extenso
    const dateMatch = line.match(/(\d{1,2}\s+de\s+\w+\s+de\s+\d{4})\s*Saldo do dia/i);
    if (dateMatch) {
      const parsedDate = parseInterExtendedDate(dateMatch[1]);
      if (parsedDate) {
        currentDate = parsedDate;
      }
      i++;
      continue;
    }
    
    // Data em formato separado
    const standaloneDateMatch = line.match(/^(\d{1,2}\s+de\s+\w+\s+de\s+\d{4})$/i);
    if (standaloneDateMatch) {
      const parsedDate = parseInterExtendedDate(standaloneDateMatch[1]);
      if (parsedDate) {
        currentDate = parsedDate;
      }
      i++;
      continue;
    }
    
    if (!currentDate) {
      i++;
      continue;
    }
    
    // FORMATO 1: Linha de tabela com pipes
    if (line.includes('|')) {
      const parts = line.split('|').map(p => p.trim()).filter(p => p);
      
      if (parts.length >= 2) {
        const description = parts[0];
        let transactionValue = 0;
        
        for (let j = 1; j < parts.length; j++) {
          const part = parts[j];
          if (/^-?R?\$?\s*[\d.,]+$/.test(part) || /^R\$\s*[\d.,]+$/.test(part) || /^-R\$\s*[\d.,]+$/.test(part)) {
            transactionValue = extractInterValue(part);
            break;
          }
        }
        
        if (description && transactionValue !== 0) {
          transactions.push({
            date: currentDate,
            description: description,
            value: transactionValue,
            lineNumber: i + 1
          });
        }
      }
      i++;
      continue;
    }
    
    // FORMATO 2: Texto livre (descrição e valores em linhas separadas)
    const isTransactionDesc = /^(Pix recebido|Pix enviado|Compra no debito|Credito liberado|Pagamento efetuado|TED recebido|DOC recebido|Ted recebido|Doc recebido)/i.test(line);
    
    if (isTransactionDesc) {
      const description = line;
      let transactionValue = 0;
      
      let j = i + 1;
      while (j < lines.length && j <= i + 3) {
        const nextLine = lines[j].trim();
        
        if (/^(Pix recebido|Pix enviado|Compra no debito|Credito liberado|Pagamento efetuado|TED recebido|DOC recebido)/i.test(nextLine) ||
            /\d{1,2}\s+de\s+\w+\s+de\s+\d{4}/i.test(nextLine)) {
          break;
        }
        
        if (/^-?R\$\s*[\d.,]+$/.test(nextLine)) {
          if (transactionValue === 0) {
            transactionValue = extractInterValue(nextLine);
          }
        }
        j++;
      }
      
      if (description && transactionValue !== 0) {
        transactions.push({
          date: currentDate,
          description: description,
          value: transactionValue,
          lineNumber: i + 1
        });
      }
      
      i++;
      continue;
    }
    
    // FORMATO 3: Linha compacta sem pipes mas com valores
    const compactMatch = line.match(/^(.+?)\s+(-?R\$\s*[\d.,]+)\s+(-?R\$\s*[\d.,]+)$/);
    if (compactMatch) {
      const description = compactMatch[1].trim();
      const transactionValue = extractInterValue(compactMatch[2]);
      
      if (description && transactionValue !== 0) {
        transactions.push({
          date: currentDate,
          description: description,
          value: transactionValue,
          lineNumber: i + 1
        });
      }
      i++;
      continue;
    }
    
    i++;
  }
  
  return transactions;
}

function parseCaixa(parts) {
  let date, description, value;
  if (parts.length >= 5) {
    date = parts[0];
    description = parts[2];
    value = parseValueWithIndicator([parts[3]]);
  } else if (parts.length >= 4) {
    date = parts[0];
    description = parts[2];
    value = parseValueWithIndicator([parts[3]]);
  }
  return { date, description, value };
}

function parseSicredi(parts) {
  let date, description, value;
  if (parts.length >= 5) {
    date = parts[0];
    description = parts[1];
    value = extractValue(parts[3]);
  } else if (parts.length >= 3) {
    date = parts[0];
    description = parts[1];
    value = extractValue(parts[2]);
  }
  return { date, description, value };
}

function parseBradesco(parts) {
  let date, description, value;
  if (parts.length >= 5) {
    date = parts[0];
    description = parts[1];
    const credit = extractValue(parts[3]);
    const debit = extractValue(parts[4]);
    value = credit > 0 ? credit : -debit;
  }
  return { date, description, value };
}

function parseItau(parts) {
  let date, description, value;
  if (parts.length >= 3) {
    date = parts[0];
    description = parts[1];
    value = parseValueWithIndicator(parts.slice(2));
  }
  return { date, description, value };
}

function parseBancoDoBrasil(parts) {
  let date, description, value;
  if (parts.length >= 5) {
    date = parts[0];
    description = parts[3];
    const valueStr = parts[4];
    value = extractValue(valueStr);
    if (valueStr.includes('(-)')) value = -Math.abs(value);
  }
  return { date, description, value };
}

function parseCressol(parts) {
  const date = parts[0];
  const description = [parts[1], parts[2]].filter(Boolean).join(' - ');
  const value = parseValueWithIndicator(parts.slice(3));
  return { date, description, value };
}

function parseGenerico(parts) {
  const date = parts[0];
  const description = parts[1] || '';
  const value = parseValueWithIndicator(parts);
  return { date, description, value };
}

// ============================================
// ROUTING - SELECIONA PARSER POR BANCO
// ============================================

function getRowParserForBank(banco) {
  const parsers = {
    'CAIXA': parseCaixa,
    'SICREDI': parseSicredi,
    'BRADESCO': parseBradesco,
    'ITAU': parseItau,
    'BANCO DO BRASIL': parseBancoDoBrasil,
    'CRESSOL': parseCressol,
    'DESCONHECIDO': parseGenerico
  };
  return parsers[banco] || parseGenerico;
}

// ============================================
// PROCESSAMENTO PRINCIPAL
// ============================================

let transactions = [];

// INTER e NUBANK têm parsers próprios que processam o arquivo completo
if (banco === 'INTER') 
{
  transactions = parseInter(data);
} 
else if (banco === 'NUBANK') 
{
  transactions = parseNubank(data);
} 
else if (banco === 'BANRISUL') 
{
  transactions = parseBanrisul(data);
} 
else 
{
  // Outros bancos: processamento linha a linha
  const parser = getRowParserForBank(banco);
  let lastDate = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = (typeof line === 'string') ? line.trim() : '';

    // Filtrar linhas de cabeçalho e irrelevantes
    if (!trimmedLine ||
        /Data\s*\|\s*Descrição/i.test(trimmedLine) ||
        /Data Movimento/i.test(trimmedLine) && /Lançamento/i.test(trimmedLine) ||
        trimmedLine.includes('Movimentações de') ||
        trimmedLine.includes('Cheque especial') ||
        trimmedLine.includes('Central de atendimento') ||
        trimmedLine.includes('Identificação') && trimmedLine.includes('Valor') ||
        trimmedLine.includes('---') ||
        trimmedLine.includes('===') ||
        containsKeyword(trimmedLine, keywords.ignore)) {
      continue;
    }

    // Separar colunas
    let parts = line.split('|');
    if (trimmedLine.startsWith('|')) {
      parts = parts.slice(1, -1);
    }
    parts = parts.map(p => p.trim());

    if (parts.length < 2) continue;

    // Chamar parser específico do banco
    let { date, description, value } = parser(parts);

    // Validar e herdar data
    if (!date || !/\d{2}\/\d{2}\/\d{4}/.test(date)) {
      date = lastDate;
    }
    if (!date || !/\d{2}\/\d{2}\/\d{4}/.test(date)) {
      continue;
    }

    lastDate = date;
    transactions.push({ 
      date, 
      description, 
      value, 
      lineNumber: i + 1 
    });
  }
}

return {
  json: {
    transactions,
    banco,
    keywords
  }
};